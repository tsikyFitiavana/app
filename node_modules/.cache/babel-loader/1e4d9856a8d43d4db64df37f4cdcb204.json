{"ast":null,"code":"if (global.GENTLY) require = GENTLY.hijack(require);\n\nvar crypto = require('crypto');\n\nvar fs = require('fs');\n\nvar util = require('util'),\n    path = require('path'),\n    File = require('./file'),\n    MultipartParser = require('./multipart_parser').MultipartParser,\n    QuerystringParser = require('./querystring_parser').QuerystringParser,\n    OctetParser = require('./octet_parser').OctetParser,\n    JSONParser = require('./json_parser').JSONParser,\n    StringDecoder = require('string_decoder').StringDecoder,\n    EventEmitter = require('events').EventEmitter,\n    Stream = require('stream').Stream,\n    os = require('os');\n\nfunction IncomingForm(opts) {\n  if (!(this instanceof IncomingForm)) return new IncomingForm(opts);\n  EventEmitter.call(this);\n  opts = opts || {};\n  this.error = null;\n  this.ended = false;\n  this.maxFields = opts.maxFields || 1000;\n  this.maxFieldsSize = opts.maxFieldsSize || 20 * 1024 * 1024;\n  this.maxFileSize = opts.maxFileSize || 200 * 1024 * 1024;\n  this.keepExtensions = opts.keepExtensions || false;\n  this.uploadDir = opts.uploadDir || os.tmpdir && os.tmpdir() || os.tmpDir();\n  this.encoding = opts.encoding || 'utf-8';\n  this.headers = null;\n  this.type = null;\n  this.hash = opts.hash || false;\n  this.multiples = opts.multiples || false;\n  this.bytesReceived = null;\n  this.bytesExpected = null;\n  this._parser = null;\n  this._flushing = 0;\n  this._fieldsSize = 0;\n  this._fileSize = 0;\n  this.openedFiles = [];\n  return this;\n}\n\nutil.inherits(IncomingForm, EventEmitter);\nexports.IncomingForm = IncomingForm;\n\nIncomingForm.prototype.parse = function (req, cb) {\n  this.pause = function () {\n    try {\n      req.pause();\n    } catch (err) {\n      // the stream was destroyed\n      if (!this.ended) {\n        // before it was completed, crash & burn\n        this._error(err);\n      }\n\n      return false;\n    }\n\n    return true;\n  };\n\n  this.resume = function () {\n    try {\n      req.resume();\n    } catch (err) {\n      // the stream was destroyed\n      if (!this.ended) {\n        // before it was completed, crash & burn\n        this._error(err);\n      }\n\n      return false;\n    }\n\n    return true;\n  }; // Setup callback first, so we don't miss anything from data events emitted\n  // immediately.\n\n\n  if (cb) {\n    var fields = {},\n        files = {};\n    this.on('field', function (name, value) {\n      fields[name] = value;\n    }).on('file', function (name, file) {\n      if (this.multiples) {\n        if (files[name]) {\n          if (!Array.isArray(files[name])) {\n            files[name] = [files[name]];\n          }\n\n          files[name].push(file);\n        } else {\n          files[name] = file;\n        }\n      } else {\n        files[name] = file;\n      }\n    }).on('error', function (err) {\n      cb(err, fields, files);\n    }).on('end', function () {\n      cb(null, fields, files);\n    });\n  } // Parse headers and setup the parser, ready to start listening for data.\n\n\n  this.writeHeaders(req.headers); // Start listening for data.\n\n  var self = this;\n  req.on('error', function (err) {\n    self._error(err);\n  }).on('aborted', function () {\n    self.emit('aborted');\n\n    self._error(new Error('Request aborted'));\n  }).on('data', function (buffer) {\n    self.write(buffer);\n  }).on('end', function () {\n    if (self.error) {\n      return;\n    }\n\n    var err = self._parser.end();\n\n    if (err) {\n      self._error(err);\n    }\n  });\n  return this;\n};\n\nIncomingForm.prototype.writeHeaders = function (headers) {\n  this.headers = headers;\n\n  this._parseContentLength();\n\n  this._parseContentType();\n};\n\nIncomingForm.prototype.write = function (buffer) {\n  if (this.error) {\n    return;\n  }\n\n  if (!this._parser) {\n    this._error(new Error('uninitialized parser'));\n\n    return;\n  }\n\n  this.bytesReceived += buffer.length;\n  this.emit('progress', this.bytesReceived, this.bytesExpected);\n\n  var bytesParsed = this._parser.write(buffer);\n\n  if (bytesParsed !== buffer.length) {\n    this._error(new Error('parser error, ' + bytesParsed + ' of ' + buffer.length + ' bytes parsed'));\n  }\n\n  return bytesParsed;\n};\n\nIncomingForm.prototype.pause = function () {\n  // this does nothing, unless overwritten in IncomingForm.parse\n  return false;\n};\n\nIncomingForm.prototype.resume = function () {\n  // this does nothing, unless overwritten in IncomingForm.parse\n  return false;\n};\n\nIncomingForm.prototype.onPart = function (part) {\n  // this method can be overwritten by the user\n  this.handlePart(part);\n};\n\nIncomingForm.prototype.handlePart = function (part) {\n  var self = this; // This MUST check exactly for undefined. You can not change it to !part.filename.\n\n  if (part.filename === undefined) {\n    var value = '',\n        decoder = new StringDecoder(this.encoding);\n    part.on('data', function (buffer) {\n      self._fieldsSize += buffer.length;\n\n      if (self._fieldsSize > self.maxFieldsSize) {\n        self._error(new Error('maxFieldsSize exceeded, received ' + self._fieldsSize + ' bytes of field data'));\n\n        return;\n      }\n\n      value += decoder.write(buffer);\n    });\n    part.on('end', function () {\n      self.emit('field', part.name, value);\n    });\n    return;\n  }\n\n  this._flushing++;\n  var file = new File({\n    path: this._uploadPath(part.filename),\n    name: part.filename,\n    type: part.mime,\n    hash: self.hash\n  });\n  this.emit('fileBegin', part.name, file);\n  file.open();\n  this.openedFiles.push(file);\n  part.on('data', function (buffer) {\n    self._fileSize += buffer.length;\n\n    if (self._fileSize > self.maxFileSize) {\n      self._error(new Error('maxFileSize exceeded, received ' + self._fileSize + ' bytes of file data'));\n\n      return;\n    }\n\n    if (buffer.length == 0) {\n      return;\n    }\n\n    self.pause();\n    file.write(buffer, function () {\n      self.resume();\n    });\n  });\n  part.on('end', function () {\n    file.end(function () {\n      self._flushing--;\n      self.emit('file', part.name, file);\n\n      self._maybeEnd();\n    });\n  });\n};\n\nfunction dummyParser(self) {\n  return {\n    end: function end() {\n      self.ended = true;\n\n      self._maybeEnd();\n\n      return null;\n    }\n  };\n}\n\nIncomingForm.prototype._parseContentType = function () {\n  if (this.bytesExpected === 0) {\n    this._parser = dummyParser(this);\n    return;\n  }\n\n  if (!this.headers['content-type']) {\n    this._error(new Error('bad content-type header, no content-type'));\n\n    return;\n  }\n\n  if (this.headers['content-type'].match(/octet-stream/i)) {\n    this._initOctetStream();\n\n    return;\n  }\n\n  if (this.headers['content-type'].match(/urlencoded/i)) {\n    this._initUrlencoded();\n\n    return;\n  }\n\n  if (this.headers['content-type'].match(/multipart/i)) {\n    var m = this.headers['content-type'].match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n    if (m) {\n      this._initMultipart(m[1] || m[2]);\n    } else {\n      this._error(new Error('bad content-type header, no multipart boundary'));\n    }\n\n    return;\n  }\n\n  if (this.headers['content-type'].match(/json/i)) {\n    this._initJSONencoded();\n\n    return;\n  }\n\n  this._error(new Error('bad content-type header, unknown content-type: ' + this.headers['content-type']));\n};\n\nIncomingForm.prototype._error = function (err) {\n  if (this.error || this.ended) {\n    return;\n  }\n\n  this.error = err;\n  this.emit('error', err);\n\n  if (Array.isArray(this.openedFiles)) {\n    this.openedFiles.forEach(function (file) {\n      file._writeStream.destroy();\n\n      setTimeout(fs.unlink, 0, file.path, function (error) {});\n    });\n  }\n};\n\nIncomingForm.prototype._parseContentLength = function () {\n  this.bytesReceived = 0;\n\n  if (this.headers['content-length']) {\n    this.bytesExpected = parseInt(this.headers['content-length'], 10);\n  } else if (this.headers['transfer-encoding'] === undefined) {\n    this.bytesExpected = 0;\n  }\n\n  if (this.bytesExpected !== null) {\n    this.emit('progress', this.bytesReceived, this.bytesExpected);\n  }\n};\n\nIncomingForm.prototype._newParser = function () {\n  return new MultipartParser();\n};\n\nIncomingForm.prototype._initMultipart = function (boundary) {\n  this.type = 'multipart';\n  var parser = new MultipartParser(),\n      self = this,\n      headerField,\n      headerValue,\n      part;\n  parser.initWithBoundary(boundary);\n\n  parser.onPartBegin = function () {\n    part = new Stream();\n    part.readable = true;\n    part.headers = {};\n    part.name = null;\n    part.filename = null;\n    part.mime = null;\n    part.transferEncoding = 'binary';\n    part.transferBuffer = '';\n    headerField = '';\n    headerValue = '';\n  };\n\n  parser.onHeaderField = function (b, start, end) {\n    headerField += b.toString(self.encoding, start, end);\n  };\n\n  parser.onHeaderValue = function (b, start, end) {\n    headerValue += b.toString(self.encoding, start, end);\n  };\n\n  parser.onHeaderEnd = function () {\n    headerField = headerField.toLowerCase();\n    part.headers[headerField] = headerValue; // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\n    var m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^\\(\\)<>@,;:\\\\\"\\/\\[\\]\\?=\\{\\}\\s\\t/]+))/i);\n\n    if (headerField == 'content-disposition') {\n      if (m) {\n        part.name = m[2] || m[3] || '';\n      }\n\n      part.filename = self._fileName(headerValue);\n    } else if (headerField == 'content-type') {\n      part.mime = headerValue;\n    } else if (headerField == 'content-transfer-encoding') {\n      part.transferEncoding = headerValue.toLowerCase();\n    }\n\n    headerField = '';\n    headerValue = '';\n  };\n\n  parser.onHeadersEnd = function () {\n    switch (part.transferEncoding) {\n      case 'binary':\n      case '7bit':\n      case '8bit':\n        parser.onPartData = function (b, start, end) {\n          part.emit('data', b.slice(start, end));\n        };\n\n        parser.onPartEnd = function () {\n          part.emit('end');\n        };\n\n        break;\n\n      case 'base64':\n        parser.onPartData = function (b, start, end) {\n          part.transferBuffer += b.slice(start, end).toString('ascii');\n          /*\n          four bytes (chars) in base64 converts to three bytes in binary\n          encoding. So we should always work with a number of bytes that\n          can be divided by 4, it will result in a number of buytes that\n          can be divided vy 3.\n          */\n\n          var offset = parseInt(part.transferBuffer.length / 4, 10) * 4;\n          part.emit('data', new Buffer(part.transferBuffer.substring(0, offset), 'base64'));\n          part.transferBuffer = part.transferBuffer.substring(offset);\n        };\n\n        parser.onPartEnd = function () {\n          part.emit('data', new Buffer(part.transferBuffer, 'base64'));\n          part.emit('end');\n        };\n\n        break;\n\n      default:\n        return self._error(new Error('unknown transfer-encoding'));\n    }\n\n    self.onPart(part);\n  };\n\n  parser.onEnd = function () {\n    self.ended = true;\n\n    self._maybeEnd();\n  };\n\n  this._parser = parser;\n};\n\nIncomingForm.prototype._fileName = function (headerValue) {\n  // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n  var m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^\\(\\)<>@,;:\\\\\"\\/\\[\\]\\?=\\{\\}\\s\\t/]+))($|;\\s)/i);\n  if (!m) return;\n  var match = m[2] || m[3] || '';\n  var filename = match.substr(match.lastIndexOf('\\\\') + 1);\n  filename = filename.replace(/%22/g, '\"');\n  filename = filename.replace(/&#([\\d]{4});/g, function (m, code) {\n    return String.fromCharCode(code);\n  });\n  return filename;\n};\n\nIncomingForm.prototype._initUrlencoded = function () {\n  this.type = 'urlencoded';\n  var parser = new QuerystringParser(this.maxFields),\n      self = this;\n\n  parser.onField = function (key, val) {\n    self.emit('field', key, val);\n  };\n\n  parser.onEnd = function () {\n    self.ended = true;\n\n    self._maybeEnd();\n  };\n\n  this._parser = parser;\n};\n\nIncomingForm.prototype._initOctetStream = function () {\n  this.type = 'octet-stream';\n  var filename = this.headers['x-file-name'];\n  var mime = this.headers['content-type'];\n  var file = new File({\n    path: this._uploadPath(filename),\n    name: filename,\n    type: mime\n  });\n  this.emit('fileBegin', filename, file);\n  file.open();\n  this.openedFiles.push(file);\n  this._flushing++;\n  var self = this;\n  self._parser = new OctetParser(); //Keep track of writes that haven't finished so we don't emit the file before it's done being written\n\n  var outstandingWrites = 0;\n\n  self._parser.on('data', function (buffer) {\n    self.pause();\n    outstandingWrites++;\n    file.write(buffer, function () {\n      outstandingWrites--;\n      self.resume();\n\n      if (self.ended) {\n        self._parser.emit('doneWritingFile');\n      }\n    });\n  });\n\n  self._parser.on('end', function () {\n    self._flushing--;\n    self.ended = true;\n\n    var done = function done() {\n      file.end(function () {\n        self.emit('file', 'file', file);\n\n        self._maybeEnd();\n      });\n    };\n\n    if (outstandingWrites === 0) {\n      done();\n    } else {\n      self._parser.once('doneWritingFile', done);\n    }\n  });\n};\n\nIncomingForm.prototype._initJSONencoded = function () {\n  this.type = 'json';\n  var parser = new JSONParser(this),\n      self = this;\n\n  parser.onField = function (key, val) {\n    self.emit('field', key, val);\n  };\n\n  parser.onEnd = function () {\n    self.ended = true;\n\n    self._maybeEnd();\n  };\n\n  this._parser = parser;\n};\n\nIncomingForm.prototype._uploadPath = function (filename) {\n  var buf = crypto.randomBytes(16);\n  var name = 'upload_' + buf.toString('hex');\n\n  if (this.keepExtensions) {\n    var ext = path.extname(filename);\n    ext = ext.replace(/(\\.[a-z0-9]+).*/i, '$1');\n    name += ext;\n  }\n\n  return path.join(this.uploadDir, name);\n};\n\nIncomingForm.prototype._maybeEnd = function () {\n  if (!this.ended || this._flushing || this.error) {\n    return;\n  }\n\n  this.emit('end');\n};","map":null,"metadata":{},"sourceType":"script"}